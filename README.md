# Attack Code Description

The code used to carry out the attacks was obtained from a public GitHub repository belonging to the user **moloch54**. The project, titled "Ddos-TCP-Middlebox-Reflection-Attack," contains the `mra.py` file used to execute the attack. After further investigation, the author of the code was identified as SÃ©bastien Meniere, a resident of Nancy, France, based on information found on his LinkedIn profile.

The code proved to be extremely useful for conducting laboratory experiments, allowing for a practical implementation of the concepts discussed in the scientific paper "Weaponizing Middleboxes for TCP Reflected Amplification" by Bock et al. With this algorithm, it was possible to experimentally replicate the **Middlebox Reflection (b)** technique, which facilitates understanding and validating amplified reflection mechanisms using middleboxes over the TCP protocol. In this technique, the source IP address is spoofed to be that of the victim, so that responses generated by the middleboxes directly hit the target.

To understand how the attack works, it is necessary to review the basic process of a TCP connection establishment, known as the **Three-Way Handshake**, which occurs in three steps:

1.  The client (SRC) sends a **SYN** packet to initiate the connection.
2.  The server (DEST) responds with a **SYN, ACK** packet, acknowledging the request.
3.  The client sends an **ACK** packet, finalizing the connection establishment.

The attack exploits the fact that, in networks with intermediary devices like firewalls or middleboxes, packets can follow different paths. The spoofed SYN packet (with `SRC=Victim`, `DST=Server possibly blocked by the middlebox`) is intercepted by the middlebox, but the real server's SYN, ACK response follows another route and is not observed by the middlebox. This creates a state inconsistency.

The attacker's trick is to send a second **ACK** packet (also with the source IP spoofed as the victim's) after the forged SYN. The middlebox, not having registered the SYN, ACK, interprets this ACK as unexpected or invalid, which can cause it to generate automatic responses like **RST** packets or, in specific cases, multiple blocking or warning messages, thereby amplifying traffic against the victim.

Additionally, the attack can be refined by using packets that contain data. For example, after sending the SYN packet, the attacker can send an **ACK+PSH** packet with a payload, such as an HTTP request:

  * Sending a **SYN** packet with a spoofed source IP address (the victim's) and a destination of domains with a high potential for middlebox blocking: `SRC=Victim`, `DST=Pornhub|Youporn|Bittorrent...`;
  * Subsequently sending an **ACK+PSH** packet with a payload, such as an HTTP GET request, also with `SRC=Victim`.

These packets, when processed by content filtering middleboxes, can trigger multiple automatic responses, reinforcing the amplification effect.

The choice to use this public code was motivated by its clear structure, which aligns with the model and methodology described in the Bock et al. study. This standardization ensured that the implementation was compliant with the attack specifications, minimized variables, and allowed for a more precise analysis of the results. Opting for a tool that was already consolidated and documented also allowed the focus to remain on the experimental and analytical aspects, avoiding code development from scratch and reducing the risk of inconsistencies that could compromise the validity of the experiments.

-----

# Code Execution

To execute the TCP amplified reflection attack code, based on the instructions provided in the repository's README.md file, the following steps are required. Before starting, you must ensure that all dependencies are properly installed and configured. The necessary tools are:

  * **tcpreplay**: Used to reproduce generated packets on a network interface.
  * **mergecap**: Used to merge packets generated by multiple threads into a single .pcap file.
  * **scapy**: A Python library used for building and manipulating TCP packets.

To install the dependencies on Debian/Ubuntu-based systems, run the following command:

```bash
sudo apt-get install tcpreplay mergecap python3-scapy
```

After ensuring the dependencies are installed, the code can be executed directly from the terminal. The command to start the attack is as follows:

```bash
sudo python3 mra.py <time_in_seconds> <target_IP>
```

Here, the `<time_in_seconds>` parameter defines how long the attack will run, and `<target_IP>` is the IP address of the target to be overloaded with the amplified traffic.

The script starts by generating forged TCP packets. It sends a SYN packet (the beginning of the TCP handshake) to the destination website (which is filtered by a middlebox). Subsequently, an ACK + PSH packet, with an HTTP payload, is sent to the same destination. This packet causes the middlebox to respond with an RST, or even an error page. The generated traffic is then stored in .pcap files and replayed indefinitely using `tcpreplay`, sending the packets to the network interface specified in the code.

To perform the attack, the command would be similar to the following example, where the attack will be executed for 300 seconds against the fictitious IP 123.4.5.6:

```bash
sudo python3 mra.py 300 123.4.5.6
```

An example of the command execution can be seen in the provided image. It is important to remember that using this code to perform attacks without authorization is illegal, unethical, and should not be used for malicious purposes. The intention is purely educational and for conducting tests in controlled environments with explicit permission for security analysis.

-----

# VMware Workstation Pro Virtualizer

For the virtualization of the target, attacker, and pfSense and FortiGate firewall virtual machines, **VMware Workstation Pro 17 for Personal Use** (version 17.6.3-24583834) was used, which is available for free for personal use. The software can be downloaded from the official VMware website, and it is necessary to register on the Broadcom portal.

VMware Workstation is a widely recognized desktop hypervisor for Windows and Linux systems, allowing users to create, run, and use virtual machines with various operating systems, such as Windows 11 and Linux distributions, without the need to reboot the computer. It is a robust and versatile platform, ideal for software development, testing, and simulations in isolated and secure virtual environments.

-----

# Laboratory Setup

The laboratory environment consisted of three distinct setups, all using the same network topology and configured with the same IP addresses. Each setup had three main components: a target, an attacker, and a middlebox, represented by a firewall. In the first scenario, the firewall was implemented using **pfSense with the pfBlockerNG add-on**. In the second scenario, the firewall was a combination of **pfSense with Squid and SquidGuard**. Finally, in the third scenario, the firewall used was a **FortiGate**.

It's worth noting that the firewalls were intentionally configured to simulate both typical corporate behavior and incorrect configurations, precisely to highlight how certain configuration choices can make these devices vulnerable to TCP amplified reflection attacks, even though they are widely used solutions in business environments.

### Target Machine

The machine used as the target in these experiments was an instance of the **Ubuntu Linux 22.04.5 LTS (Jammy)** operating system, a popular open-source desktop operating system with good long-term support. Its virtual hardware specifications are as follows:

  * **RAM:** 4096 MB
  * **Processor:** 2 vCPUs
  * **Storage:** 25 GB
  * **Network Adapters:** 1000 Mb/s (Intel Gigabit Internet 82545EM)

The VM is equipped with two network interfaces. The first is connected to the LAN segment, identified as LAN in VMware, simulating the machine's presence in a protected local network behind the firewall. The second interface is configured in NAT mode and is used exclusively for internet access through the host computer's connection, allowing for the download of updates, packages, and other necessary external communications.

The network configuration for the target machine was defined as follows:

  * **Hostname:** `Ubuntu`
  * **LAN IP Address:** `192.168.24.61/24` (ens34)
  * **INTERNET IP Address:** IP assigned via DHCP (ens37)
  * **Default Gateway:** `192.168.24.100`
  * **DNS Server:** `192.168.24.100`

### Attacker Machine

The machine used as the attacker in the experiments was based on the **Kali Linux** operating system, version 2025.1 (kali-rolling). Its virtual hardware specifications are:

  * **RAM:** 8096 MB
  * **Processor:** 6 vCPUs
  * **Storage:** 32 GB
  * **Network Adapters:** 1000 Mb/s (Intel Gigabit Internet 82545EM)

The attacker VM has two network interfaces. The first is connected to the WAN segment, identified as WAN in VMware, simulating a machine located on the internet, outside the protected environment. This interface allows the VM to act as an external agent attempting to attack the target machine within the internal network. The second interface is configured in NAT mode and is used exclusively for internet access through the host computer's connection, allowing for the download of updates, packages, and other external communications necessary to prepare the attack environment.

The network configuration for the attacker machine was defined as follows:

  * **Hostname:** `kali`
  * **WAN IP Address:** `10.0.0.2/24` (eth0)
  * **INTERNET IP Address:** IP assigned via DHCP (eth1)
  * **Default Gateway:** `10.0.0.1`

### pfSense Firewall

The first firewall used in the experiments was **pfSense Community Edition (CE)**, version `2.7.2-RELEASE`. It is an open-source firewall software distribution based on FreeBSD that can be installed on a physical computer or a virtual machine to create a dedicated network firewall.

The virtual hardware specifications assigned to the machine are:

  * **RAM:** 2048 MB
  * **Processor:** 2 vCPUs
  * **Storage:** 20 GB
  * **Network Adapters:** 1000 Mb/s (Intel Gigabit Internet 82545EM)

The pfSense VM was configured with three network interfaces:

  * **em0:** Connected to the WAN segment, identified in VMware as WAN, simulating the exit of internal machines toward the internet.
  * **em1:** Connected to the other LAN segment, identified as LAN, representing the internal access interface to the firewall.
  * **em3:** Configured in NAT mode and used exclusively to allow internet access via the host computer's connection, enabling the download of updates, packages, and other external communications necessary to prepare the attack environment.

The network configuration for the virtual firewall machine was defined as follows:

  * **Hostname:** `pfSense.home.arpa`
  * **WAN IP Address (em0):** `10.0.0.1/24`
  * **LAN IP Address (em1):** `192.168.24.100/24`
  * **INTERNET IP Address (em2):** assigned via DHCP.

**NAT Outbound** was configured to redirect traffic from the LAN network to the WAN interface, simulating the internal network's exit to the external network through the firewall.

The firewall rules configured for the WAN interface included:

  * A rule that allows the reception of **ICMP (ping)** packets originating from external machines to internal LAN machines.
  * A rule that allows **ping** from external machines directly to the pfSense WAN interface IP address.
  * A rule that allows external access to the target's **Web server** on port 80/TCP, simulating its public exposure.
  * A rule that allows machines on the internal network to freely access all websites, which would later be restricted by the `pfBlockerNG` and `squidGuard` filtering solutions responsible for blocking domains like `youporn.com`, `facebook.com`, `pornhub.com`, and `bittorrent.com` and processed before this rule.

For the LAN interface, the rules were configured to contain the default `anti-lockout rule` and the `default allow LAN to any` and `default allow LAN IPv6 to any` rules, which permit unrestricted outbound traffic from the LAN.

#### pfSense Firewall + pfBlockerNG

**pfBlockerNG** is an add-on package available in pfSense that acts as a blocker of malicious domains and IPs, offering advanced network access control functionalities through the use of external lists. It allows administrators to block entire categories of websites, such as pornography, social media, gambling, and others. One of its main functions is the use of **DNSBL (DNS Blackhole List)**, which intercepts DNS queries and responds with local addresses, preventing access to certain domains. Additionally, pfBlockerNG also works with lists of malicious IPs, enabling the creation of firewall rules to block traffic associated with those addresses.

To allow the blocking of prohibited sites, an explicit **DROP** rule was added to the top of the LAN interface rules for packets originating from the internal network destined for the IP addresses associated with prohibited sites, which were obtained and maintained through IP lists configured directly in pfBlockerNG.

The package also allows for a blocking page to be displayed to the user whenever they try to access a prohibited domain or IP. This page is hosted locally on the pfSense itself and serves to inform that the content has been blocked by network security policies. However, it's important to note that **pfBlockerNG does not perform a real redirection of the request**: it merely responds with a local IP without changing the URL displayed in the browser. This means that, despite showing the blocking page, the original request is not actually redirected.

This behavior has important implications in the context of TCP reflection attacks exploiting middleboxes. Since the middlebox (in this case, pfSense with pfBlockerNG) does not perform active redirection or re-sending of content, it is **unable to reflect the blocking page to an external target**. Therefore, pfBlockerNG is not useful for executing amplification attacks based on this type of response, as the entire blocking process occurs locally and does not directly interact with the final destination of the traffic.

#### pfSense Firewall + Squid + SquidGuard

**Squid** is a web caching proxy widely used in corporate, educational, and experimental environments. It acts as an intermediary between clients (like browsers) and internet servers, caching frequently accessed web pages. This allows for significant bandwidth savings and an improvement in response time for end-users. In addition to its caching functionalities, Squid also offers advanced features for access control, content filtering, user authentication, and detailed request logging. It is compatible with various protocols, such as HTTP, HTTPS, and FTP, and can be run on multiple platforms. Squid is distributed under the GNU GPL license, making it a free, robust, and highly configurable solution.

Integrated with Squid, **SquidGuard** is a URL redirector that complements the proxy's functionalities by offering content filtering mechanisms based on lists of domains, categories, or regular expressions. With this feature, it's possible to block access to unwanted or potentially dangerous sites and redirect the user to a custom blocking page. To enable the blocking of prohibited sites, a list of target categories was created in the SquidGuard Proxy Filter service in pfSense.

SquidGuard was the main component used in this experiment precisely because it allows for a **real redirection of the request**, changing the URL displayed in the browser and sending the blocking page directly to the user who tries to access restricted content.

### FortiGate Firewall

The second firewall used in the experiments was the **NGFW FortiGate-VM64**, version 7.2.0, which was chosen because it was on the list of vulnerable versions, as identified by the CVE-2022-27491 vulnerability. FortiGate NGFWs offer advanced protection for users and data, combining security functionalities with high performance through Fortinet's dedicated processors. It is a consolidated and widely adopted commercial solution in the market.

Large institutions, such as the University of BrasÃ­lia (UnB), actively adopt this solution to ensure the security of their networks. A practical example of this use can be seen in the provided image, which shows the blocking page displayed by Fortigate when a user tries to access a prohibited site. This test was performed within UnB itself, confirming the institution's effective use of the system. Additionally, the same page can be viewed on the target machine when doing the same in the lab.

The specifications for the virtual environment used in the tests are as follows:

  * **RAM:** 2048 MB
  * **Processor:** 1 vCPU
  * **Storage:** Not specified
  * **Network Adapter:** 10000 Mb/s (Intel Gigabit Internet 82545EM)

Adopted as a substitute for pfSense, the FortiGate firewall was configured with three network interfaces, replicating the topology and function assigned in the previous configuration. The network configuration for the firewall was defined as follows:

  * **Hostname:** `FortiGate-VM64-KVM`
  * **WAN IP Address:** `10.0.0.1/24` (port1)
  * **LAN IP Address:** `192.168.24.100/24` (port2)
  * **INTERNET IP Address:** IP assigned via DHCP (port3)

Given the finding that neither pfBlockerNG nor Squid with SquidGuard was able to reflect blocking pages back to the victim during the tests, it was necessary to find a more suitable alternative for the experiment's objectives. In this context, the decision was made to use **FortiGate**, a next-generation firewall solution developed by Fortinet, which proved to be more effective for the proposed scenario.

FortiGate was chosen for offering a content filtering mechanism that is more integrated into the network flow, with the real ability to intercept connections and respond directly with custom blocking pages that are effectively sent to the client as complete HTTP responses. Unlike the previous solutions, FortiGate does not depend on DNS manipulation or explicit proxies to display blocking messages; it acts directly on the traffic with **deep packet inspection (DPI)** and an immediate response, which increases the chance of the page being reflected to the spoofed destination in amplification attacks.

Furthermore, FortiGate allows for more granular control over security policies and responses, with specific tools for customizing blocking messages, session analysis, and behavior-based connection handling. These features make the solution more suitable for advanced security tests and for analyzing how middleboxes interact with spoofed traffic.

Therefore, the use of FortiGate represented an evolution in the experimental methodology, offering greater control and visibility over traffic, as well as a higher potential for generating useful reflected responses for the study of TCP amplification attacks based on middleboxes.

FortiGate was configured with firewall rules similar to those created in pfSense, which allow **ICMP** packets from the WAN to the LAN and outbound traffic from the LAN to the WAN through the FortiGate. A **Web Filter** profile was created to block prohibited sites and was subsequently applied to the LAN access rules.
